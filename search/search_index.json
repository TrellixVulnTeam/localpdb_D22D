{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"localpdb localpdb provides a simple framework to store the local mirror of the protein structures available in the PDB database and other related resources. The underlying data can be conveniently browsed and queried with the pandas.DataFrame structures. Update mechanism allows following the weekly PDB releases while retaining the possibility to access previous data versions. You may find localpdb particularly useful if you: already use Biopython Bio.PDB.PDBList or similar modules and tools like CCPDB , build custom protein datasets based on multiple criteria, e.g. for machine learning purposes, create pipelines based on the multiple or all available protein structures, are a fan of pandas DataFrames . Overview To find more about the package and its functionalities please follow the docs . In case of any troubles free to contact us or open an issue. Installation pip install localpdb Setup the database and sync protein structures in the mmCIF format: localpdb_setup -db_path /path/to/localpdb --fetch_cif More information on the setup options are available via docs . Examples Find the number of entries added to the PDB every year from localpdb import PDB lpdb = PDB ( db_path = '/path/to/your/localpdb' ) lpdb . entries = lpdb . entries . query ( 'deposition_date.dt.year >= 2015 & deposition_date.dt.year <= 2020' ) df = lpdb . entries . groupby ( by = [ 'method' , lpdb . entries . deposition_date . dt . year ])[ 'mmCIF_fn' ] . count () . reset_index () sns . barplot ( data = df , x = 'deposition_date' , y = 'mmCIF_fn' , hue = 'method' ) Create a custom dataset of protein chains Select: human SAM-dependent methyltransferases , solved with X-ray diffraction , with resolution below 2.5 Angstrom deposited after 2010 . remove the redundancy at the 90% sequence identity , # Install plugins providing additional data localpdb_setup -db_path /path/to/your/localpdb -plugins SIFTS ECOD PDBClustering from localpdb import PDB import gzip lpdb . entries = lpdb . entries . query ( 'type == \"prot\"' ) # Protein structures lpdb . entries = lpdb . entries . query ( 'method == \"diffraction\"' ) # solved with X-ray diffraction lpdb . entries = lpdb . entries . query ( 'resolution <= 2.5' ) # with resolution below 2.5A lpdb . entries = lpdb . entries . query ( 'deposition_date.dt.year >= 2010' ) # added after 2010 lpdb . chains = lpdb . chains . query ( 'ncbi_taxid == \"9606\"' ) # human proteins lpdb . ecod = lpdb . ecod . query ( 't_name == \"S-adenosyl-L-methionine-dependent methyltransferases\"' ) # SAM dependent methyltransferases # Remove redundancy (select only representative structure from each sequence cluster) lpdb . load_clustering_data ( redundancy = 90 ) lpdb . chains = lpdb . chains [ lpdb . chains [ 'clust-90' ] . notnull ()] representative = lpdb . chains . groupby ( by = 'clust-90' )[ 'resolution' ] . idxmin () lpdb . chains = lpdb . chains . loc [ representative ] lpdb . chains . to_csv ( 'dataset.csv' ) # Save dataset Advanced examples Assessing conformational variability from the ensemble of structures of Sars-COV main protease . Amino acid preferences among the viral coiled-coil domains . Acknowledgments This work was supported by the National Science Centre grant 2017/27/N/NZ1/00716 .","title":"Home"},{"location":"#localpdb","text":"localpdb provides a simple framework to store the local mirror of the protein structures available in the PDB database and other related resources. The underlying data can be conveniently browsed and queried with the pandas.DataFrame structures. Update mechanism allows following the weekly PDB releases while retaining the possibility to access previous data versions. You may find localpdb particularly useful if you: already use Biopython Bio.PDB.PDBList or similar modules and tools like CCPDB , build custom protein datasets based on multiple criteria, e.g. for machine learning purposes, create pipelines based on the multiple or all available protein structures, are a fan of pandas DataFrames .","title":"localpdb"},{"location":"#overview","text":"To find more about the package and its functionalities please follow the docs . In case of any troubles free to contact us or open an issue.","title":"Overview"},{"location":"#installation","text":"pip install localpdb Setup the database and sync protein structures in the mmCIF format: localpdb_setup -db_path /path/to/localpdb --fetch_cif More information on the setup options are available via docs .","title":"Installation"},{"location":"#examples","text":"","title":"Examples"},{"location":"#find-the-number-of-entries-added-to-the-pdb-every-year","text":"from localpdb import PDB lpdb = PDB ( db_path = '/path/to/your/localpdb' ) lpdb . entries = lpdb . entries . query ( 'deposition_date.dt.year >= 2015 & deposition_date.dt.year <= 2020' ) df = lpdb . entries . groupby ( by = [ 'method' , lpdb . entries . deposition_date . dt . year ])[ 'mmCIF_fn' ] . count () . reset_index () sns . barplot ( data = df , x = 'deposition_date' , y = 'mmCIF_fn' , hue = 'method' )","title":"Find the number of entries added to the PDB every year"},{"location":"#create-a-custom-dataset-of-protein-chains","text":"Select: human SAM-dependent methyltransferases , solved with X-ray diffraction , with resolution below 2.5 Angstrom deposited after 2010 . remove the redundancy at the 90% sequence identity , # Install plugins providing additional data localpdb_setup -db_path /path/to/your/localpdb -plugins SIFTS ECOD PDBClustering from localpdb import PDB import gzip lpdb . entries = lpdb . entries . query ( 'type == \"prot\"' ) # Protein structures lpdb . entries = lpdb . entries . query ( 'method == \"diffraction\"' ) # solved with X-ray diffraction lpdb . entries = lpdb . entries . query ( 'resolution <= 2.5' ) # with resolution below 2.5A lpdb . entries = lpdb . entries . query ( 'deposition_date.dt.year >= 2010' ) # added after 2010 lpdb . chains = lpdb . chains . query ( 'ncbi_taxid == \"9606\"' ) # human proteins lpdb . ecod = lpdb . ecod . query ( 't_name == \"S-adenosyl-L-methionine-dependent methyltransferases\"' ) # SAM dependent methyltransferases # Remove redundancy (select only representative structure from each sequence cluster) lpdb . load_clustering_data ( redundancy = 90 ) lpdb . chains = lpdb . chains [ lpdb . chains [ 'clust-90' ] . notnull ()] representative = lpdb . chains . groupby ( by = 'clust-90' )[ 'resolution' ] . idxmin () lpdb . chains = lpdb . chains . loc [ representative ] lpdb . chains . to_csv ( 'dataset.csv' ) # Save dataset","title":"Create a custom dataset of protein chains"},{"location":"#advanced-examples","text":"Assessing conformational variability from the ensemble of structures of Sars-COV main protease . Amino acid preferences among the viral coiled-coil domains .","title":"Advanced examples"},{"location":"#acknowledgments","text":"This work was supported by the National Science Centre grant 2017/27/N/NZ1/00716 .","title":"Acknowledgments"},{"location":"api/","text":"","title":"Api"},{"location":"ex1/","text":"Assessing conformational variability from the ensemble of structures of Sars-COV main protease. import gzip import pytraj as pt import seaborn as sns import matplotlib.pyplot as plt from localpdb import PDB from Bio.PDB import Select from Bio.PDB.PDBParser import PDBParser from Bio.PDB import PDBIO from sklearn.cluster import KMeans parser = PDBParser ( QUIET = True ) # PDB files parser writer = PDBIO () # PDB files writer #################################### ### HELPER FUNCTIONS AND CLASSES ### def is_continous ( list_ ): \"\"\" Checks whether an arbitrary list is numerically continous, i.e. n, n+1, n+2, .... \"\"\" try : return all ([ int ( list_ [ i ]) == int ( list_ [ i + 1 ]) - 1 for i in range ( 0 , len ( list_ ) - 1 )]) except ValueError : return False class CustomSelect ( Select ): \"\"\" Only accept the specified chains and residues when saving a PDB structure. \"\"\" def __init__ ( self , chain , beg_idx , end_idx ): self . ch , self . beg , self . end = chain , beg_idx , end_idx def accept_residue ( self , residue ): return ( self . beg <= residue . get_id ()[ 1 ] and self . end >= residue . get_id ()[ 1 ]) def accept_atom ( self , atom ): if ( not atom . is_disordered ()) or atom . get_altloc () == 'A' or atom . get_altloc () == '1' : atom . set_altloc ( ' ' ) if atom . get_name () == 'CA' : return True return False def accept_chain ( self , chain ): return chain . get_id () == self . ch ################################ ################################ lpdb = PDB ( '/ssd/db/localpdb_dev' , plugins = [ 'PDBSeqresMapper' ]) # Load localpdb and the Mapper plugin seq = 'SGFRKMAFPSGKVEGCMVQVTCGTTTLNGLWLDDVVYCPRHVICTSEDMLNPNYEDLLIRKSNHNFLVQAGNVQLRVIGHSMQNCVLKLKVDTANPKTPKYKFVRIQPGQTFSVLACYNGSPSGVYQCAMRPNFTIKGSFLNGSCGSVGFNIDYDCVSFCYMHHMELPTGVHAGTDLEGNFYGPFVDRQTAQAAGTDTTITVNVLAWLYAAVINGDRWFLNRFTTTLNDFNLVAMKYNYEPLTQDHVDILGPLSAQTGIAVLDMCASLKELLQNGMNGRTILGSALLEDEFTPFDVVRQCSGVTFQ' # Search entries that match the input sequence with 100% identity lpdb . search_seq ( sequence = seq , identity = 1 , select = True ) # Iterate over all entries and save coordinates only with the CA atoms # Extract only the CA atoms that correspond to the 5-295 residue range according to the natural sequence. fns = [] for pdb_chain , sequence in lpdb . chains [ 'sequence' ] . to_dict () . items (): pdb , chain = pdb_chain . split ( '_' ) mapping = lpdb . get_pdbseqres_mapping ( pdb_chain , reverse = True ) indices = ( mapping [ 5 ], mapping [ 295 ]) if is_continous ( list ( mapping . keys ())) else None if indices : beg , end = indices with gzip . open ( lpdb . entries . loc [ pdb , 'pdb_fn' ], 'rt' ) as f : s = parser . get_structure ( 's' , f )[ 0 ] writer . set_structure ( s ) writer . save ( f 'CA/ { pdb_chain } .pdb' , select = CustomSelect ( chain , int ( beg ), int ( end ))) fns . append ( f 'CA/ { pdb_chain } .pdb' ) # Use pytraj to perform PCA traj = pt . load ( fns , top = fns [ 0 ]) pca = pt . pca ( traj , '@CA' , n_vecs = 2 , fit = True , ref = 0 ) # Cluster the PCA representation km = KMeans ( n_clusters = 4 ) km . fit ( pca [ 0 ] . T ) # Plot sns . kdeplot ( pca [ 0 ][ 0 ], pca [ 0 ][ 1 ], thresh =. 1 , linewidth = 0.1 ) plt . scatter ( pca [ 0 ][ 0 ], pca [ 0 ][ 1 ], s = 25 , c = km . labels_ ) plt . xlabel ( r 'PC1 ($\\AA$)' , fontsize = 14 ) plt . ylabel ( r 'PC2 ($\\AA$)' , fontsize = 14 ) plt . savefig ( 'PCA.png' , dpi = 300 )","title":"Example 1"},{"location":"ex2/","text":"Amino acid preferences among the viral coiled-coil domains import pandas as pd import seaborn as sns import matplotlib.pyplot as plt from localpdb import PDB lpdb = PDB ( '/ssd/db/localpdb_dev' , plugins = [ 'Socket' ]) # Select only viral proteins lpdb . search ( attribute = 'struct_keywords.pdbx_keywords' , operator = 'contains_phrase' , value = 'VIRAL PROTEIN' , no_hits =- 1 , select = True ) # Select only entries containing coiled-coil domain lpdb . entries = lpdb . entries [ lpdb . entries [ 'socket_7.0' ] . notnull ()] # Only X-ray entries with resolution higher than 2 A lpdb . entries = lpdb . entries . query ( 'method == \"diffraction\"' ) lpdb . entries = lpdb . entries . query ( 'resolution <= 2.0' ) # Get socket data dictionary socket = lpdb . get_socket_dict ( method = 'heptads' ) stats = { pos : { aa : 0 for aa in 'AILVCDEFGHKMNPQRSTWYX' } for pos in 'abcdefg' } # Iterate over all coiled-coil domains and compute stats for entry , ccs in socket . items (): for cc in ccs . values (): for seq , hept_register in zip ( cc [ 'sequences' ] . values (), cc [ 'heptads' ] . values ()): for aa , hept in zip ( seq , hept_register ): stats [ hept ][ aa ] += 1 # Plot df = pd . DataFrame . from_dict ( stats ) plt . figure ( figsize = ( 10 , 10 )) ax = sns . heatmap ( df , cmap = 'viridis' , cbar = False ) ax . set_xticklabels ( ax . get_xmajorticklabels (), fontsize = 18 ) ax . set_yticklabels ( ax . get_ymajorticklabels (), fontsize = 16 , rotation = 45 )","title":"Example 2"},{"location":"lpdb/","text":"localpdb.PDB() Arguments Argument Description db_path location of the localpdb database version version of the localpdb database to load (default: version='latest' ) auto_filter automatically propagates selections performed on any of the DataFrames to other DataFrames (default: auto_filter=True ). See the example below for more information. plugins Names of the plugins to load Example from localpdb import PDB lpdb = PDB ( db_path = '/ssd/db/localpdb' , version = 'latest' , auto_filter = True ) lpdb . entries = lpdb . entries . query ( lpdb . entries . query ( 'method == \"diffraction\"' )) lpdb.entries was updated and since auto_filter=True the selection will be also propagated to lpdb.chains . In other words lpdb.chains will contain only the chains corresponding to the entries present in lpdb.entries . Attributes Attribute Description entries pandas.DataFrame containing all entries available in the loaded PDB release. More info . chains pandas.DataFrame containing all chains (polymer entity instances) in the loaded PDB release. More info . version timestamp of the loaded PDB data, in the format YYYYMMDD (e.g. 20210507 ) Methods Method Description reset() Resets all selections performed on any of the DataFrames and restores the initial state of PDB object. load_plugin(plugin='Name') Loads plugins and its data. select_updates(mode='am+') Selects only the entries that were either added ( mode='a' ) or ( mode='m' ) or both ( mode='am' ) in the latest PDB weekly release. In mode='am+' updates with respect to the previous localpdb version will be loaded. search() Info available on separate page search_seq() Info available on separate page search_seq_motif() Info available on separate page search_struct() Info available on separate page","title":"localpdb.PDB"},{"location":"lpdb/#arguments","text":"Argument Description db_path location of the localpdb database version version of the localpdb database to load (default: version='latest' ) auto_filter automatically propagates selections performed on any of the DataFrames to other DataFrames (default: auto_filter=True ). See the example below for more information. plugins Names of the plugins to load Example from localpdb import PDB lpdb = PDB ( db_path = '/ssd/db/localpdb' , version = 'latest' , auto_filter = True ) lpdb . entries = lpdb . entries . query ( lpdb . entries . query ( 'method == \"diffraction\"' )) lpdb.entries was updated and since auto_filter=True the selection will be also propagated to lpdb.chains . In other words lpdb.chains will contain only the chains corresponding to the entries present in lpdb.entries .","title":"Arguments"},{"location":"lpdb/#attributes","text":"Attribute Description entries pandas.DataFrame containing all entries available in the loaded PDB release. More info . chains pandas.DataFrame containing all chains (polymer entity instances) in the loaded PDB release. More info . version timestamp of the loaded PDB data, in the format YYYYMMDD (e.g. 20210507 )","title":"Attributes"},{"location":"lpdb/#methods","text":"Method Description reset() Resets all selections performed on any of the DataFrames and restores the initial state of PDB object. load_plugin(plugin='Name') Loads plugins and its data. select_updates(mode='am+') Selects only the entries that were either added ( mode='a' ) or ( mode='m' ) or both ( mode='am' ) in the latest PDB weekly release. In mode='am+' updates with respect to the previous localpdb version will be loaded. search() Info available on separate page search_seq() Info available on separate page search_seq_motif() Info available on separate page search_struct() Info available on separate page","title":"Methods"},{"location":"lpdb_chains/","text":"localpdb.PDB.chains Column Description pdb PDB identifier, corresponds with lpdb.entries DataFrame sequence Protein sequence deposition_date Date of deposition to PDB resolution Resolution (available for methods: diffraction , EM ) method Method of structure determination ( diffraction , EM , NMR ) fn Filename of the extracted structure of the chain (requires PDBChain plugin) ncbi_taxid NCBI taxonomy identifier (requires SIFTS plugin) Warning The sequence available in the sequence column does not necessarily match the sequence in the protein structure. The mapping between these can be obtained with the PDBSeqresMapper plugin. In the case of multiple NCBI taxonomy identifiers are mapped to a protein chain, only the first one is presented. Example lpdb.chains pdb sequence deposition_date resolution method 4ctg_AU 4ctg VTNVGEDGEPGETEPRHALSPVDMHVHTDVSFLLDRFFDVETLE.... 2014-03-13 00:00:00 17 EM 5aol_B 5aol SSSVPSQKTYQGSYGFRLGFLHSGTAKSVTC... 2015-09-10 00:00:00 1.5 diffraction 1awt_F 1awt VNPTVFFDIAVDGEPLGRVSFELFADKVPKTAENFRALSTGEKGF... 1997-10-05 00:00:00 2.55 diffraction 5bts_A 5bts GIVEQCCTSICSLYQLENYCN 2015-06-03 00:00:00 1.77 diffraction 3v4d_E 3v4d LYFQGHMPKSVIIPAGSSAPLAPFVPGTLADGVVYVSGTLAFD.... 2011-12-14 00:00:00 1.95 diffraction","title":"localpdb.PDB.chains"},{"location":"lpdb_entries/","text":"localpdb.PDB.entries Column Description type Type of entry ( prot , prot-nuc ) method Method of structure determination ( diffraction , EM , NMR ) resolution Resolution (available for methods: diffraction , EM ) deposition_date Date of deposition to PDB pdb_fn Filename of the structure in the PDB format (if structure mirror is available) mmCIF_fn Filename of the structure in the mmCIF format (if structure mirror is available) biounit Filename of the biological assembly generated with the MakeMultimer.py script (requires Biounit plugin) socket_7.* Filename of the Socket (program detecting coiled-coil domains) output Biounit and Socket plugins) dssp Filename of the DSSP file (requires DSSP plugin) Warning Some large protein structures will not be available in the PDB format - in such case there'll be an np.nan value in the pdb_fn column. Currently, entries containing solely the nucleic acids are not shown in the lpdb.entries Example lpdb.entries type method resolution deposition_date pdb_fn 4fd7 prot diffraction 1.8 2012-05-26 00:00:00 /ssd/db/localpdb/mirror/pdb/fd/pdb4fd7.ent.gz 6gz5 prot-nuc EM 3.5 2018-07-03 00:00:00 not_compatible 6efv prot diffraction 2.341 2018-08-17 00:00:00 /ssd/db/localpdb/mirror/pdb/ef/pdb6efv.ent.gz 3eqb prot diffraction 2.62 2008-09-30 00:00:00 /ssd/db/localpdb/mirror/pdb/eq/pdb3eqb.ent.gz 3lq4 prot diffraction 1.98 2010-02-08 00:00:00 /ssd/db/localpdb/mirror/pdb/lq/pdb3lq4.ent.gz ... ... ... ... ... ...","title":"localpdb.PDB.entries"},{"location":"lpdb_search/","text":"localpdb . PDB . search ( attribute , operator , value , return_type = 'entry' , no_hits = 1000 , get_doc_only = False , select = False ) Performs a basic search using the RCSB API. More information available at the RCSB website . Returns the DataFrame with entries satisfying the query and, sometimes, additional scoring information. Parameter Description attribute Attribute to perform a search on - the full list is available here . operator Operator to use in the search - full list of operators available with corresponding attributes is available here . value Value used in the search. return_type Format of the returned entries that satisfy the query. Available options are entry ( PDBID ), polymer_entity ( PDBID_ENTITY ), polymer_instance ( PDBID_CHAIN ), no_hits Number of presented hits. Default: no_hits=1000 , use no_hits=-1 to get all hits. get_doc_only Present only the dataframe with available attributes and operators. select If True the results of the query will be used to perform selection on lpdb.entries (if return_type=='entries' ) or lpdb.chains (if return_type=='polymer_instance' ). Moreover, if lpdb is instantiated with auto_filter mode, the selection will be propagated to other registered dataframes. localpdb . PDB . search_sequence ( sequence , evalue = 1 , identity = 0.9 , return_type = \"polymer_instance\" , no_hits = 1000 , select = False ) Search for similar sequences to the input sequence among the entries available in the PDB database. Returns the DataFrame with sequences similar to the query and similarity statistics. Parameter Description sequence Input sequence. evalue Minimum e-value to include a sequence. identity Minimum identity to the query to include a sequence. return_type Format of the returned entries that satisfy the query. Available options are entry ( PDBID ), polymer_entity ( PDBID_ENTITY ), polymer_instance ( PDBID_CHAIN ), no_hits Number of presented hits. Default: no_hits=1000 , use no_hits=-1 to get all hits. select If True the results of the query will be used to perform selection on lpdb.entries (if return_type=='entries' ) or lpdb.chains (if return_type=='polymer_instance' ). Moreover, if lpdb is instantiated with auto_filter mode, the selection will be propagated to other registered dataframes. localpdb . PDB . search_struct ( pdb_id , assembly_id = 1 , operator = 'strict_shape_match' , return_type = \"entry\" , no_hits = 1000 , select = False ) Search for structures spatially similar to the input structures. Returns the DataFrame with structures similar to the query and similarity statistics. Parameter Description pdb_id Input structure identifier. assembly_id Assembly identifier of the input structure. operator Match mode type - either relaxed_shape_match or strict_shape_match . return_type Format of the returned entries that satisfy the query. Available options are entry ( PDBID ), polymer_entity ( PDBID_ENTITY ), polymer_instance ( PDBID_CHAIN ), no_hits Number of presented hits. Default: no_hits=1000 , use no_hits=-1 to get all hits. select If True the results of the query will be used to perform selection on lpdb.entries (if return_type=='entries' ) or lpdb.chains (if return_type=='polymer_instance' ). Moreover, if lpdb is instantiated with auto_filter mode, the selection will be propagated to other registered dataframes. localpdb . PDB . search_seq_motif ( query , type_ = 'prosite' , return_type = \"entry\" , no_hits = 1000 , select = False ) Search for a sequence motif in entries available in the PDB database. Returns the DataFrame with the entries containing the specified sequence motif. Parameter Description query Query motif to find in the PDB sequences, according to given type_ (i.e prosite) type_ Type of the specified motif. Available: simple (e.g., CXCXXL ), prosite (e.g., C-X-C-X(2)-[LIVMYFWC] ), regex (e.g., CXCX{2}[LIVMYFWC] ) return_type Format of the returned entries that satisfy the query. Available options are entry ( PDBID ), polymer_entity ( PDBID_ENTITY ), polymer_instance ( PDBID_CHAIN ), no_hits Number of presented hits. Default: no_hits=1000 , use no_hits=-1 to get all hits. select If True the results of the query will be used to perform selection on lpdb.entries (if return_type=='entries' ) or lpdb.chains (if return_type=='polymer_instance' ). Moreover, if lpdb is instantiated with auto_filter mode, the selection will be propagated to other registered dataframes.","title":"localpdb.PDB.search*"},{"location":"overview/","text":"Overview Basic setup and functionalities The simplest localpdb setup mode can be obtained by running the following command. This will give access to the lpdb.entries and lpdb.chains dataframes. Example localpdb_setup -db_path /path/to/localpdb In order to sync the protein structures (either in PDB or mmCIF formats), you can rerun localpdb_setup at any time with the following parameters: Example localpdb_setup -db_path /path/to/localpdb --fetch_pdb --fetch_cif You can also install plugins providing additional data with localpdb_setup (also at any time, not necessarily during the initial setup): Example localpdb_setup -db_path /path/to/localpdb -plugins Plugin1 Plugin2 The detailed information about the available plugins and their functionalities is available on a separate page . Updates Every week new entries are added to the PDB database, some are removed or modified. To track these changes you can easily update your localpdb database (this'll also update any installed plugins): Example localpdb_setup -db_path /path/to/localpdb --update","title":"Overview"},{"location":"overview/#overview","text":"","title":"Overview"},{"location":"overview/#basic-setup-and-functionalities","text":"The simplest localpdb setup mode can be obtained by running the following command. This will give access to the lpdb.entries and lpdb.chains dataframes. Example localpdb_setup -db_path /path/to/localpdb In order to sync the protein structures (either in PDB or mmCIF formats), you can rerun localpdb_setup at any time with the following parameters: Example localpdb_setup -db_path /path/to/localpdb --fetch_pdb --fetch_cif You can also install plugins providing additional data with localpdb_setup (also at any time, not necessarily during the initial setup): Example localpdb_setup -db_path /path/to/localpdb -plugins Plugin1 Plugin2 The detailed information about the available plugins and their functionalities is available on a separate page .","title":"Basic setup and functionalities"},{"location":"overview/#updates","text":"Every week new entries are added to the PDB database, some are removed or modified. To track these changes you can easily update your localpdb database (this'll also update any installed plugins): Example localpdb_setup -db_path /path/to/localpdb --update","title":"Updates"},{"location":"plugin_guide/","text":"In construction....","title":"Build a custom plugin"},{"location":"plugins/","text":"Currently available plugins and description Current selection of plugins is determined mainly by the scientific interest of our lab. If you would like to include a new data source do not hesitate to contact us or follow a dedicated guideline . Plugin Description SIFTS Provides easy access to the SIFTS data. Adds new dataframes lpdb.pfam , lpdb.scop , lpdb.ec , lpdb.cath and an additional column in the lpdb.chains dataframes containing taxonomy information. Biounit Precalculates the biological assemblies from the raw PDB entries with the MakeMultimer script. ECOD Provides access to the ECOD data. Adds new dataframe lpdb.ecod . DSSP Precalculates the DSSP output for each entry in the PDB. Adds a dssp in the lpdb.entries . PDBClustering Enables the access to the precomputed clustering results from the RCSB . Adds the localpdb.PDB.load_clustering_data function and subsequently the clust-* column(s) in the lpdb.chains DataFrame. PDBSeqresMapper Provides the mapping between the names of residues in the PDB/mmCIF file and SEQRES (natural) protein sequence. Mapping is available through the localpdb.PDB.get_pdbseqres_mapping() function. Socket Calculates the coiled-coil domain annotations in the available protein structures with the Socket program. Adds a localpdb.PDB.get_socket_dict function that returns the parsed annotation for the current lpdb.entries selection. PDBChain Provides easy access to the precalculated PDB files corresponding to the individual chains (polymer instances)","title":"Overview"},{"location":"plugins/#currently-available-plugins-and-description","text":"Current selection of plugins is determined mainly by the scientific interest of our lab. If you would like to include a new data source do not hesitate to contact us or follow a dedicated guideline . Plugin Description SIFTS Provides easy access to the SIFTS data. Adds new dataframes lpdb.pfam , lpdb.scop , lpdb.ec , lpdb.cath and an additional column in the lpdb.chains dataframes containing taxonomy information. Biounit Precalculates the biological assemblies from the raw PDB entries with the MakeMultimer script. ECOD Provides access to the ECOD data. Adds new dataframe lpdb.ecod . DSSP Precalculates the DSSP output for each entry in the PDB. Adds a dssp in the lpdb.entries . PDBClustering Enables the access to the precomputed clustering results from the RCSB . Adds the localpdb.PDB.load_clustering_data function and subsequently the clust-* column(s) in the lpdb.chains DataFrame. PDBSeqresMapper Provides the mapping between the names of residues in the PDB/mmCIF file and SEQRES (natural) protein sequence. Mapping is available through the localpdb.PDB.get_pdbseqres_mapping() function. Socket Calculates the coiled-coil domain annotations in the available protein structures with the Socket program. Adds a localpdb.PDB.get_socket_dict function that returns the parsed annotation for the current lpdb.entries selection. PDBChain Provides easy access to the precalculated PDB files corresponding to the individual chains (polymer instances)","title":"Currently available plugins and description"},{"location":"setup/","text":"Installation Installing localpdb The setup of the localpdb is simple and straightforward. Recommended installation way is to use pip (this will also make the localpdb_setup script available in your PATH ): pip install localpdb The most recent version of localpdb can be installed directly from the repository: pip install git+https://github.com/labstructbioinf/localpdb.git Setting up localpdb Once installed localpdb you need to setup the database in a suitable directory: localpdb_setup -db_path /path/to/localpdb Setup script provides additional options if you want to additionally keep the updatable archive of the raw protein structures in various formats or to select the desired PDB mirror: Option Description -db_path PATH Path to store the localpdb database -mirror MIRROR PDB mirror used to download the raw files. Valid options are: - rcsb (RCSB PDB - US - default ), - pdbe (PDBe - UK), - pdbj (PDBj - Japan) -plugins PLUGINS Install plugins fetching additional data. More on plugins. --fetch_pdb Download the protein structures in the PDB format --fetch_cif Download the protein structures in the mmCIF format --update Update localpdb database instead of setting up. More on updates. Example Setting up localpdb in directory /ssd/db/localpdb , syncing structures in PDB and mmCIF formats and installing plugins PDBClustering and ECOD : localpdb_setup -db_path /ssd/db/localpdb --fetch_pdb --fetch_cif -plugins ECOD PDBClustering","title":"Setup"},{"location":"setup/#installation","text":"","title":"Installation"},{"location":"setup/#installing-localpdb","text":"The setup of the localpdb is simple and straightforward. Recommended installation way is to use pip (this will also make the localpdb_setup script available in your PATH ): pip install localpdb The most recent version of localpdb can be installed directly from the repository: pip install git+https://github.com/labstructbioinf/localpdb.git","title":"Installing localpdb"},{"location":"setup/#setting-up-localpdb","text":"Once installed localpdb you need to setup the database in a suitable directory: localpdb_setup -db_path /path/to/localpdb Setup script provides additional options if you want to additionally keep the updatable archive of the raw protein structures in various formats or to select the desired PDB mirror: Option Description -db_path PATH Path to store the localpdb database -mirror MIRROR PDB mirror used to download the raw files. Valid options are: - rcsb (RCSB PDB - US - default ), - pdbe (PDBe - UK), - pdbj (PDBj - Japan) -plugins PLUGINS Install plugins fetching additional data. More on plugins. --fetch_pdb Download the protein structures in the PDB format --fetch_cif Download the protein structures in the mmCIF format --update Update localpdb database instead of setting up. More on updates. Example Setting up localpdb in directory /ssd/db/localpdb , syncing structures in PDB and mmCIF formats and installing plugins PDBClustering and ECOD : localpdb_setup -db_path /ssd/db/localpdb --fetch_pdb --fetch_cif -plugins ECOD PDBClustering","title":"Setting up localpdb"}]}